If question ask to return a minimum value then most probably it is a Greedy algorithm Plm.
ascii value of 0 to 9 is [48 to 57]
//char to int is char ch  = '5'
we do int = ch-'0', int  = 5

set main st.insert() for add and st.erase() for remove element 

uppercase asciii value 65 to 90 and lowercase 97 to 122

ceil of value of [n/2] = (n+1)/2;

COMPARATOR OPERATOR
auto lambda = [](int a, int b ){
     return a > b ; //desc
}

sort(begin(arr), end(arr), lambda); // sort element in desc order;

For priority queue
//if freq same then store element in lexical order
        auto lambda = [](pair<int,string>p1 , pair<int,string>p2){
            if(p1.first == p2.first){
                return p1.second > p2.second;
            }
            return p1.first < p2.first;
        };

priority_queue<pair<int,string>, vector<pair<int,string>>, decltype(lambda)> pq(lambda);

sort array in decrease order 
sort<arr.begin(),arr.end(),greater<int>);

#priority Queue
by defalut priority queue makes max heap
max heap && max priority queue = max value element will come out first from queue then next max
pq.top() will always be max value inside queue
min heap && min priority queue = min value element will come out first from queue then next min
pq.top() will always be min value inside queue

max heap = priority_queue<int>pq;
min heap = priority_queue<int, vector<int>, greater<int>>pq;

min head and max heap both are complete binary tree


//XOR properties
 a xor a = 0
 a xor 0 = a
 (a xor b) xor c = a xor (b xor c)
 a xor b = b xor a

// count no of 1's bit in the number
 int a = __builtin_popcount(num1);

//Bitwise XOR of two same no is ZERO 
//Bitwise XOR of O and no is no itselft

// Use binary search to find the first valid potion
auto it = lower_bound(potions.begin(), potions.end(), required_potion);

find  Ciel value with floating point and works with integer
Ceil Division=  (a+b-1)/b;


Yes, isdigit() is a standard library function in C++ that checks if a given character is a digit (0–9).
string(1, s[i]) creates a string of length 1 containing the character s[i]

temp.clear(); to empty the dynamic array vector<int>temp
iteration in sorted-map happens in increasing order of key 

//CONVERT iTH CHARACTER PRESENT IN THE STRING TO INTERGER .So, num[i] - '0' converts the character at position i in the string num to its corresponding integer value.
num[i] = 5 ==>  char ch = num[i]; 
int val = ch - '0' ==> integer value of ch
5 - '0' will be integer 5 ;

// Char ch = s[i]  and s has lower and upper alphabet
ch -'A' => gives int value in range [0,25] depent upon ch like it ch => B then B-'A' = 1 becoz B = 66 and A = 65 so 66-65 = 1;
ch -'a' => gives int value in range [0,25]


//TO CONVERT UPPERCASE CHAR IN TEMP TO LOWER CASE USING FUNCTION tolower
 for(auto ch : temp){
          ans  += tolower(ch);
       }

//range of char ==>> [0,255] INCLUDE ALPHABET , SYMBOLS , NUMBERS ;


You can remove the boiler plate code and do ==>
#include<bits/stdc++.h>
using namespace std;
// namespace is used to get the difference between user defined function name or variable name and predefined function name and prefefined name.
//std stands for standard template dictonary
//stl stands for standard template library which contain container , iteraotr and algorithm 
//constructor is special function which automatically call when the class is created to assign the memory and name is same as class
//deconstructor is functino which automatically call when the class is destroyed to remove from memory and name is same as class

//reverse in a range of [l,r]
reverse(s.begin()+l,s.begin()+r);

//empty set in one go 
//mySet.clear();



int main(){
int a , n , m;
cin >> a >> n >> m ;
string a , b ;
cin >> a >> b ;

function call;

cout << value is << endl;
return 0 ;
}

 vector<pair<int,int>>ans;//to store the pair of number 

huset store elements in sorted order to find min or max simply use set.rbegin() = max and set.begin() = min elements. window length = right -left +1;

Set.find(s[right])!=Set.end() check where element present in set or not if present return true else return false 

Set.find(s[right])==Set.end()check where element present in set or not if not present return true else return false

Cal asci value of ch ={0,1,2...} and mp it to index i to arr LastSeen  ==> lastSeen[s[i]-'a'] = i;

mp[nums[i]] = i; ==> mp of <key,value> where key = index (RHS ) and value is inside the bracket mp[];

mp[nums[i]]++; ==> mp of <key,value> where key  = frequency (RHS = ++) and value is inside the bracket mp[value] = key;

 int maxi = *max_element(arr.begin(), arr.end()); to find maximum element in the arr 
  this is an interator pointing to largest value index max_element(arr.begin(), arr.end()) to get its value we use this "*"

Ans to get the index of largest element max_element(arr.begin(), arr.end()) this is pointer will not return value so we use this statement
max_element(arr.begin(), arr.end()) - arr.begin(); to return its index value;

int mini = *min_element(arr.begin(), arr.end()); to find mniimum element in the arr

  int sumofArr = accumulate(arr.begin(),arr.end(),0); to find the sum of an arr

 arr.push_back(nums1[i++]); this is used to add element in nums1 array and increase the count of i simultaneously

arr3[ind++] = arr1[i++]; initialize the value of arr1[i] to arr3[ind] and then increment the value of ind and i simultaneously

if the size of an array is very large then initialize the array as pass by reference not  pass by value  as it create the copy of 
array and by reference it pass as pointer and change the value simultaneoulty to origin array but not in case of pass by value
as it  only create copy of original array becoz it will lead to memory limit exceed error

s= string(v.begin(), v.end()) is a concise and efficient way to create a new string from the contents of the vector.return the modified string.
 and It avoids the need for manual iteration and concatenation of characters 

ascii value of A-Z = [65 - 90]   
acsii value of a-z = [97 - 122]
ascii valiue of number from 0 - 9 = [48 - 57]



sort(arr.begin() , arr.end() , greater<int>()) sort the arr in the dcreasing order here greater<int>() => it is a comparator operator 

Greedy Problem ==> TAKE THE MINIUMN VALUE FIRST AS IT IS GREEDY PROBLEM 

BACKTRACKING  ==> TAKE THE ELEMENT THEN DO THE RECURSION CALL AND THEN REMOVET THAT ELEMENT THEN THEN AGAIN DO THE RECURSION CALL 
LIKE ===>    PUSH_BACK(NUMS[I]) SOLVE(FUNCTION)  POP_BACK(NUMS[I]) SOLVE(FUNCTION)

C++ Lambda Function for Sorting by Increasing Frequency
sort(nums.begin(), nums.end(), [&](int a, int b) {
    if (freq[a] == freq[b]) {
        return a > b; 
    }
    return freq[a] < freq[b];
});

SORT THE VALUES IN THE MAP ==>  for(auto &it : mp){sort(it.second.begin(),it.second.end())}

DIAGONAL SORT THE MATRIX / => [i+j] 
DIAGONAL SORT THE MATRIX \ => [i-j]

maximum value of int datatype is 10^9 so to prevent ans from bufferOverflow we uses the modulo ==> 10e9 + 7 and 
RETURN ANS AS  ANS  = (ANS + NUMS[i]) % MOD ;  WHERE MOD = 10e9 + 7;

{&&} ==> AND CONDITION 
{&} ==> AND OPERATOR 

STOI ==> STRING VALUE TO INTEGER VALUE AS STRING  == "255" TO CONVET IT INTO INTEGER USE STOI

The isdigit() function internally converts the character to its ASCII value.
If the ASCII value falls within the range of ‘0’ to ‘9’, it returns a non-zero value (indicating that the character is a digit).

vector_name.insert(position, value); insert value in vector
EXAMPLE =. VECTOR [9,9] => ANS.INSERT(ANS.BEGIN(),1)
RESULT ==> [1,0,0]  
VECTOR = [2,3,6] => ANS.INSET(ANS.BEGIN()+1,4)
RESULT ==> [2,4,3,6]
VECTOR = [2,3,6] => ANS.INSET(ANS.BEGIN()+2,10)
RESULT ==> [2,3,10,6]

INSERT ELEMENT IN VECTOR TEMP USE SIMPLE TEMP.PUSH_BACK(NUMS[I])

//CONVERT INTEGER TO STRING 
string  a = to_string(n);
// CONVERT STRING TO INTEGER
int n = stoi(temp) 
//CONVERT LARGE STRING TO INTEGER
long long n = stoll(temp)


//IN BINARY SEARCH TREE WHICH ALWAY HAS SMALLER THAN ROOT AT LEFT AND BIGGER THAN ROOT AT RIGHT
SO, IN ORDER TO STORE VALUE IN SORTED ORDER OF BST WE CAN USE INORDER TRAVERSAL WHICH STORE VALUE IN SORTED ORDER


EXPRESS JS IS NODE.JS FRAMWORK
REACT.JS IS A LIBRARY 
NODE.JS IS A JAVASCRIPT RUNTIME ENVIRONMENT

NODE_MODULES ARE CORE NODE.JS PACKAGE INSTALL AT TIME OF DOWNLOAD
npm init  initilalize the json file and npm i packageName installs the package of node.js 

getline(cin,str) ---> TO read all sentences with space 
ss.stringstream

NoSQL is schemaless and ex -> MONGODB AND FIREBASE
SQL is schema and table like structure ie -->  MySQL

Reference vs. Value:
slow == fast checks if the pointers reference the same node.
slow->data == fast->data checks if the values contained in those nodes are the same.

slow == fast is critical for determining if there is a cycle in the list.
slow->data == fast->data can be used for comparing node values but is not useful for detecting cycles.
















































































