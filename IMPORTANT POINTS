huset store elements in sorted order to find min or max simply use set.rbegin() = max and set.begin() = min elements. window length = right -left +1;

Set.find(s[right])!=Set.end() check where element present in set or not if present return true else return false 

Set.find(s[right])==Set.end()check where element present in set or not if not present return true else return false

Cal asci value of ch ={0,1,2...} and mp it to index i to arr LastSeen  ==> lastSeen[s[i]-'a'] = i;

mp[nums[i]] = i; ==> mp of <key,value> where key = index (RHS ) and value is inside the bracket mp[];

mp[nums[i]]++; ==> mp of <key,value> where key  = frequency (RHS = ++) and value is inside the bracket mp[value] = key;

 int maxi = *max_element(arr.begin(), arr.end()); to find maximum element in the arr 
  this is an interator pointing to largest value index max_element(arr.begin(), arr.end()) to get its value we use this "*"

Ans to get the index of largest element max_element(arr.begin(), arr.end()) this is pointer will not return value so we use this statement
max_element(arr.begin(), arr.end()) - arr.begin(); to return its index value;

int mini = *min_element(arr.begin(), arr.end()); to find mniimum element in the arr

  int sumofArr = accumulate(arr.begin(),arr.end(),0); to find the sum of an arr

 arr.push_back(nums1[i++]); this is used to add element in nums1 array and increase the count of i simultaneously

arr3[ind++] = arr1[i++]; initialize the value of arr1[i] to arr3[ind] and then increment the value of ind and i simultaneously

if the size of an array is very large then initialize the array as pass by reference not  pass by value  as it create the copy of 
array and by reference it pass as pointer and change the value simultaneoulty to origin array but not in case of pass by value
as it  only create copy of original array becoz it will lead to memory limit exceed error

s= string(v.begin(), v.end()) is a concise and efficient way to create a new string from the contents of the vector.return the modified string.
 and It avoids the need for manual iteration and concatenation of characters 

ascii value of A-Z = [65 - 90]   
acsii value of a-z = [97 - 122]
ascii valiue of number from 0 - 9 = [48 - 57]

sort(arr.begin() , arr.end() , greater<int>()) sort the arr in the dcreasing order here greater<int>() => it is a comparator operator 

Greedy Problem ==> TAKE THE MINIUMN VALUE FIRST AS IT IS GREEDY PROBLEM 

BACKTRACKING  ==> TAKE THE ELEMENT THEN DO THE RECURSION CALL AND THEN REMOVET THAT ELEMENT THEN THEN AGAIN DO THE RECURSION CALL 
LIKE ===>    PUSH_BACK(NUMS[I]) SOLVE(FUNCTION)  POP_BACK(NUMS[I]) SOLVE(FUNCTION)

C++ Lambda Function for Sorting by Increasing Frequency
sort(nums.begin(), nums.end(), [&](int a, int b) {
    if (freq[a] == freq[b]) {
        return a > b; 
    }
    return freq[a] < freq[b];
});

SORT THE VALUES IN THE MAP ==>  for(auto &it : mp){sort(it.second.begin(),it.second.end())}

DIAGONAL SORT THE MATRIX / => [i+j] 
DIAGONAL SORT THE MATRIX \ => [i-j]


int n 

